# =============================================================================
# GitLab CI/CD Pipeline for Node.js API
# =============================================================================
# This pipeline automates:
# 1. Building the Docker image
# 2. Pushing to Harbor private registry
# 3. Deploying to Kubernetes cluster
# =============================================================================

# Define pipeline stages in execution order
stages:
  - build
  - push
  - deploy

# =============================================================================
# Global Variables
# =============================================================================
variables:
  # Harbor registry configuration
  HARBOR_REGISTRY: "134.209.232.225:8080"
  HARBOR_PROJECT: "production"
  IMAGE_NAME: "api"

  # Full image path with tag
  IMAGE_TAG: "${HARBOR_REGISTRY}/${HARBOR_PROJECT}/${IMAGE_NAME}:${CI_COMMIT_SHORT_SHA}"
  IMAGE_LATEST: "${HARBOR_REGISTRY}/${HARBOR_PROJECT}/${IMAGE_NAME}:latest"

  # Docker-in-Docker configuration
  DOCKER_HOST: tcp://docker:2375
  DOCKER_TLS_CERTDIR: ""
  DOCKER_DRIVER: overlay2

# =============================================================================
# Build Stage
# =============================================================================
# Builds the Docker image from Dockerfile
build:
  stage: build
  image: docker:24-dind
  services:
    - name: docker:24-dind
      # Allow insecure registry for Harbor HTTP
      command: ["--insecure-registry=134.209.232.225:8080"]
  before_script:
    # Login to Harbor registry
    - echo "$HARBOR_PASSWORD" | docker login $HARBOR_REGISTRY -u $HARBOR_USERNAME --password-stdin
  script:
    # Build the Docker image with commit SHA tag and DATABASE_URL for Prisma generate
    - docker build --build-arg DATABASE_URL="$DATABASE_URL" -t $IMAGE_TAG -t $IMAGE_LATEST .
    # Save image for next stage (optional - can also push directly here)
    - docker save $IMAGE_TAG > image.tar
  artifacts:
    paths:
      - image.tar
    expire_in: 1 hour
  only:
    - master
    - main

# =============================================================================
# Push Stage
# =============================================================================
# Pushes the built image to Harbor registry
push:
  stage: push
  image: docker:24-dind
  services:
    - name: docker:24-dind
      command: ["--insecure-registry=134.209.232.225:8080"]
  before_script:
    - echo "$HARBOR_PASSWORD" | docker login $HARBOR_REGISTRY -u $HARBOR_USERNAME --password-stdin
  script:
    # Load the image from previous stage
    - docker load < image.tar
    # Tag as latest
    - docker tag $IMAGE_TAG $IMAGE_LATEST
    # Push both tagged and latest versions
    - docker push $IMAGE_TAG
    - docker push $IMAGE_LATEST
  dependencies:
    - build
  only:
    - master
    - main

# =============================================================================
# Deploy Stage
# =============================================================================
# Deploys to Kubernetes cluster
deploy:
  stage: deploy
  image: alpine/k8s:1.31.3
  before_script:
    # Configure kubectl with cluster credentials
    # Option 1: Using kubeconfig file (stored as CI/CD variable)
    - mkdir -p ~/.kube
    - echo "$KUBE_CONFIG" | base64 -d > ~/.kube/config
    - chmod 600 ~/.kube/config
  script:
    # Update the deployment with new image
    - kubectl set image deployment/myapi-deployment myapi=$IMAGE_TAG --record
    # Wait for rollout to complete
    - kubectl rollout status deployment/myapi-deployment --timeout=300s
    # Show deployment status
    - kubectl get pods -l app=myapi
  environment:
    name: production
    url: http://134.209.232.225:31000
  only:
    - master
    - main

# =============================================================================
# Optional: Deploy to Staging (on develop branch)
# =============================================================================
deploy_staging:
  stage: deploy
  image: alpine/k8s:1.31.3
  before_script:
    - mkdir -p ~/.kube
    - echo "$KUBE_CONFIG_STAGING" | base64 -d > ~/.kube/config
    - chmod 600 ~/.kube/config
  script:
    - kubectl set image deployment/myapi-deployment myapi=$IMAGE_TAG --record
    - kubectl rollout status deployment/myapi-deployment --timeout=300s
  environment:
    name: staging
  only:
    - develop
  when: manual

# =============================================================================
# Optional: Rollback Job (manual trigger)
# =============================================================================
rollback:
  stage: deploy
  image: alpine/k8s:1.31.3
  before_script:
    - mkdir -p ~/.kube
    - echo "$KUBE_CONFIG" | base64 -d > ~/.kube/config
    - chmod 600 ~/.kube/config
  script:
    # Rollback to previous deployment
    - kubectl rollout undo deployment/myapi-deployment
    - kubectl rollout status deployment/myapi-deployment --timeout=300s
  environment:
    name: production
  when: manual
  only:
    - master
    - main
